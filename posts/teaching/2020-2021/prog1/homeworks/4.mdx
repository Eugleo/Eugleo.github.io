export const metadata = {
  title: 'Functions are fun',
  timestamp: new Date(2020, 9 - 1, 21).valueOf(),
  due: new Date(2020, 9 - 1, 27).valueOf(),
  lectures: [3],
  points: 10,
};

Pochopení této látky je **naprosto zásadní**. Nemyslím tím to, že by bylo nutné vše pochopit hned, spíše se snažím naznačit, že opsat úkol od kamaráda vám v tomto případě z dlouhodobého hlediska nepomůže.

Toto je jeden z delších úkolů, proto doporučuji nedělat jej na poslední chvíli, ale každý den si nad ním sednout, trochu se zamyslet a kousek vyřešit. S řešením by vám mělo pomoct mrknout se na "Opakování z hodiny" níže.

## Zadání

Každý úkol má několik podúkolů (úrovní). Podmínky pro získání základního počtu bodů (10) jsou:

1. Splnit z každého úkolu alespoň jeho nejlehčí úroveň
2. Alespoň z jednoho úkolu splnit i nějaký složitější podúkol

Za každý podúkol navíc dostanete **extra body** (podle jeho složitosti) až do maximálního cekového počtu 20 bodů. Podúkoly spolu soouvisí jen velmi volně, tj. **úroveň 2 není nutně rozšířenou verzí funkce z úrovně 1** nebo něco podobného.

Všechny úlohy řešte napsáním pouze jedné funkce (není-li řečeno jinak), a to způsobem, jaký jsme si ukazovali na poslední přednášce — tj. funkce volá samu sebe. Všechna zadání u sebe mají testy s několika modelovými vstupy a výstupy; to by vám mělo pomoci zjistit, zda se vaše řešení ubírá správným směrem.

Doporučuji vám proto prostě zkopírovat zadání a dopsat do něj své řešení.

### První úkol (number)

Úroveň 1

```python
fun sum-n(n :: Number) -> Number:
  doc: "Returns the sum of all numbers from 0 to [n]: 0 + 1 + 2 + ... + n"
  ...
where:
  sum-n(-10) is 0
  sum-n(-5) is 0
  sum-n(0) is 0
  sum-n(1) is 1
  sum-n(2) is 1 + 2
  sum-n(3) is 1 + 2 + 3
end
```

Úroveň 2 (1 bod)

```python
fun num-power(base :: Number, power :: Number) -> Number:
  doc: "Returns [base] to the power of [power]. [power] is always non-negative (i.e. 0 or higher)"
  ...
where:
  num-power(-1, 3) is -1
  num-power(-1, 2) is 1
  num-power(3, 3) is 27
  num-power(3, 0) is 1
  num-power(5, 2) is 25
end
```

Úroveň 3 (1 bod)

```python
fun count-factors(upper-bound :: Number, n :: Number) -> Number:
  doc: "Counts the positive numbers that are less than or equal to [upper-bound] that are divisible by [n]"
  ...
where:
  count-factors(10, 2) is 5 # i.e. 2, 4, 6, 8, 10
  count-factors(10, 5) is 2 # i.e. 5, 10
  count-factors(7, 1) is 7 # i.e. 1, 2, 3, 4, 5, 6, 7
end
```

Jak zjistíte, kdy je jedno číslo dělitelné jiným (beze zbytku)? Mrkněte na funkci `num-modulo`.

### Druhý úkol (string)

Ke všem třem úrovním budete potřebovat funkce `string-first` a `string-rest`, které můžete naimportovat pomocí

```python
include shared-gdrive("string-utils", "1QChebN-p7mUEmccxwsn-3Xz6X-4k9gFd")
```

Funkce `string-first(str)` vrací první písmeno ve stringu `str`, zatímco `string-rest` vrací zbytek stringu (tj. od druhého písmena dál). Příklady:

```python
string-first("Evžen") # -> "E"
string-rest("Evžen") # -> "vžen"

string-first("retPy") # -> "r"
string-rest("retPy") # -> "etPy"

string-first("n") # -> "n"
string-rest("n") # -> ""

string-first("") # -> ""
string-rest("") # -> ""

# Vždy platí
string-first(str) + string-rest(str) is str
```

Úroveň 1

```python
fun drop-n(n :: Number, str :: String) -> String:
  doc: "Returns [str] with its first [n] characters removed. [n] is always non-negative."
  ...
where:
  drop-n(0, "Evžen") is "Evžen"
  drop-n(1, "Evžen") is "vžen"
  drop-n(2, "Evžen") is "žen"
  drop-n(5, "Evžen") is ""
  drop-n(20, "Evžen") is ""
end
```

Úroveň 2 (2 body)

```python
fun char-at(index :: Number, str :: String) -> String:
  doc: "Returns the character at the index [index]. [index] is always somewhere in the string."
  ...
where:
  char-at(0, "Pyret") is "P"
  char-at(1, "Pyret") is "y"
  char-at(4, "Pyret") is "t"
end
```

Úroveň 3 (2 body)

```python
fun replace-character(
  char :: String,
  replacement :: String,
  str :: String) -> String:
  doc: "Returns [str] with all occurences of [char] replaced by [replacement]. [char] is always one character."
  ...
where:
  replace-character("E", "e", "Evžen") is "evžen"
  replace-character("E", "Ne", "Evžen") is "Nevžen"
  replace-character("ž", "", "Evžen") is "Even"
  replace-character("a", "b", "Evžen") is "Evžen"
  replace-character("e", "oo", "bumblebee") is "bumblooboooo"
end
```

### Třetí úkol (boolean)

U druhé a třetí úrovně se opět budou chodit funkce `string-first` a `string-rest`, viz kapitola "Druhý úkol (string)" výše.

Úroveň 1

```python
fun divides(n :: Number, k :: Number) -> Boolean:
  doc: "Returns true if [n] is divisible by [k], false otherwise. [k] is always positive (i.e. greater than 0)"
  ...
where:
  divides(1, 1) is true
  divides(2, 2) is true
  divides(3, 2) is false
  divides(4, 2) is true
  divides(10, 10) is true
  divides(10, 1) is true
  divides(10, 5) is true
  divides(10, 7) is false
  divides(10, 20) is false
end
```

Úroveň 2 (1 bod)

```python
fun string-has-character(character :: String, str :: String) -> Boolean:
  doc: "Returns true if [character] is somewhere in [str], false otherwise. [character] is always one character"
  ...
where:
  string-has-character("E", "Evžen") is true
  string-has-character("V", "Evžen") is false
  string-has-character("v", "Evžen") is true
  string-has-character("v", "") is false
  string-has-character("a", "abracadabra") is true
end
```

Úroveň 3 (2 body)

Parametry `str` budou u obou následujících funkcí stringy skládající se pouze z `f` a `t`, kde `f` má představovat `false` a `t` zase `true`.

```python
fun all(str :: String) -> Boolean:
  doc: "Returns true if [str] doesn't have any 'f' in it, false otherwise"
  # In other words, it is a bit like a generalization of 'and', everything has to be true
  ...
where:
  all("") is true
  all("t") is true
  all("f") is false
  all("tttt") is true
  all("tttttf") is false
end

fun any(str :: String) -> Boolean:
  doc: "Returns true if [str] has at least one 't' in it, false otherwise"
  # In other words, it is a bit like a generalization of 'or', at least one thing has to be true
  ...
where:
  any("") is false
  any("t") is true
  any("f") is false
  any("tttt") is true
  any("tttttf") is true
end
```

### Čtrvtý úkol (image)

Úroveň 1

```python
fun repeat-image-h(n :: Number, img :: Image ) -> Image:
  doc: "Repeats the image [n] times (horizontally). [n] is always non-negative"
  ...
where:
  test-img = rectangle(100, 100, "solid", "blue")

  # empty-image is imported automatically with include image
  repeat-image-h(0, test-img) is empty-image
  repeat-image-h(1, test-img) is beside(empty-image, test-img)
  repeat-image-h(2, test-img) is beside(test-img, test-img)
  repeat-image-h(3, test-img) is beside(beside(test-img, test-img), test-img)
end
```

Úroveň 2 (1 bod)

```python
fun stripe(n :: Number) -> Image:
  doc: "Returns a striped line made from [n] 50x50 squares with alternating blue/red colors. [n] is non-negative."
  ...
where:
  blue-square = rectangle(50, 50, "solid", "blue")
  red-square = rectangle(50, 50, "solid", "red")

  # empty-image is imported automatically with include image
  stripe(0) is empty-image
  stripe(1) is beside(blue-square, empty-image)
  stripe(2) is beside(red-square, beside(blue-square, empty-image))
  stripe(3) is beside(blue-square, beside(red-square, beside(blue-square, empty-image)))
end
```

Na lichých místech chcete modré čtverce, na sudých červené. Bude se vám hodit funkce `num-modulo`.

Příklady:

<img className="mb-4" src="/recursion-stripe.png" />

Úroveň 3 (3 body)

```python
fun rotate-n-times(n, img):
  doc: "Overlays [n] images over themselves in such a way that the result is symetric, by rotating every image by the same angle"

  # Compute the angle here and pass it to rotate-n-times-angle
  ...
end

fun rotate-n-times-angle(n, angle, img):
  doc: "Overlays [n] images over themselves by rotating each next image by [angle]"
  ...
end
```

Příklady:

<img className="mb-4" src="/recursion-rotate.png" />

## Opakování z hodiny

Chceme napsat funkci `repeat-string(str :: String, num :: Number) -> String`, která daný string `num`-krát zopakuje. Například

```python
>>> repeat-string("a", 4)
"aaaa"
```

Jak na to? Pojďme nejprve napsat funkci, která zopakuje daný string dvakrát. K tomu využijeme operátor `+`, kterým jdou sčítat nejen čísla, ale také stringy:

```python
>>> "Já jsem" + " " + "Evžen"
"Já jsem Evžen"
```

Naše funkce bude vypadat následovně:

```python
fun repeat-string-twice(str :: String) -> String:
  str + str
where:
  repeat-string-twice("a") is "aa"
  repeat-string-twice("Hello") is "HelloHello"
end
```

Toto bylo jednoduché. Co třeba funkce, která ho zopakuje třikrát? To zvládneme obdobně snadno

```python
fun repeat-string-thrice(str :: String) -> String:
  str + str + str
where:
  repeat-string-thrice("a") is "aaa"
  repeat-string-thrice("Hello") is "HelloHelloHello"
end
```

Všimněme si, že tuto naši poslední funkci můžeme napsat i za použití funkce `repeat-string-twice`. Klidně si sami ověřte v Pyretu, že to funguje!

```python
fun repeat-string-thrice(str :: String) -> String:
  # str + str jsme nahradili voláním repeat-string-twice
  # ta totiž to "str + str" udělá za nás
  repeat-string-twice(str) + str
  # ^ původně str + str ^
where:
  repeat-string-thrice("a") is "aaa"
  repeat-string-thrice("Hello") is "HelloHelloHello"
end
```

A samozřejmě, tělo naší funkce můžeme zapsat dvěma způsoby.

```python
# Buďto
repeat-string-twice(str) + str

# Nebo za použití proměnné
str2 = repeat-string-twice(str)
str2 + str
# str2 je v tomto případě výsledek repeat-string-twice(str)
# je tedy roven str + str
```

Už se pomalu blížíme našem kýženému `repeat-string`, ale ještě než se na něj vrhneme, zamyslete se, jak by asi vypadala funkce `repeat-string-four-times`. Zvládli byste ji napsat pomocí `repeat-string-thrice`? (řešení si zkontrolujte na konci textu)

### Obecný `repeat-string` v1

Zezačátku se nabízí ručně kontrolovat, kolikrát že bychom ten string měli zopakovat, a podle toho to ručně vrátit výsledek:

```python
fun repeat-string-v1(str :: String, num :: Number) -> String:
  if num == 1:
    str
  else if num == 2:
    str + str
  else if num == 3:
    str + str + str
  else if ...:
    ...
  end
end
```

Tato funkce má jednu drobnou nevýhodu — pokud bychom chtěli ručně zkontrolovat všechny hodnoty `num`, měla by ta funkce nekonečno řádků.

### Obecný `repeat-string` v2

Všimněme si, že k napsání "repeat-thrice" výše jsme použili "repeat-twice", a k napsání "opakuj čtyřikrát" zase "opakuj třikrát". Dává to rozum, vždyť abychom něco opakovali třikrát, musíme to zopakovat nejprve dvakrát _a pak_ ještě jednou navrch. Jinými slovy

```python
"HelloHelloHello" = "HelloHello" + "Hello"

"HelloHelloHelloHello" = "HelloHelloHello" + "Hello"
```

Toto samozřejmě nekončí u čtyřky — když chceme nějakých string _n-krát_ zopakovat, je to to samé jako bychom jej zopakovali _(n-mínus-jedna)-krát_ a pak navrch ještě jednou. Tento poznatek uplatníme v druhém pokusu o funkci `repeat-string`:

```python
fun repeat-string-v2(str :: String, num :: Number) -> String:
  # Zopakovat string n-krát je to samé jako...

  # ...zopakovat jej (n-mínus-jedna)-krát
  str-n-minus-one = repeat-string-v2(str, n - 1)

  # ...a pak navrch ještě jednou (toto je náš výsledek)
  str-n-minus-one + str
end
```

Zkuste si tuto funkci definovat u sebe v Pyretu a pak jí zavolat s nějakým vstupem, například `repeat-string-v2("a", 3)`. Vyjde vám `"aaa"`? **Co se stane?**

Spoiler: Funkce nikdy nedoběhne. Když si zahrajeme na počítač a zkusíme si funkci spustit ručně, uvidíme, proč to tak je.

```python
# Voláme
repeat-string("a", 3)

# A ta v průběhu zavolá
repeat-string-v2("a", 2)
# ...aby to mohla uložit do str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", 1)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -1)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -2)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -3)
# ...aby to mohla uložit do svojí str-n-minus-one

# ...atd, nikdy se nezastavíme, vždy jen zmenšíme num o jedničku
# a zavoláme se znovu
```

Pořád je to ale lepší než `v1`; komu se chce psát nekonečno řádků? Zkusme tedy tuto verzi jen trochu upravit tak, abychom odstranili tento poslední problém.

### Obecný `repeat-string` v3

Je zřejmé, že se nemůžeme volat donekonečna s čím dál menšími `num`, tj. že se u nějakého `num` musíme zastavit. Když má naše funkce zopakovat daný string `num`-krát, u jakého `num` je vhodné se zastavit? Můžeme pro začátek zvolit nějaký náhodný, pro který se bude dobře ručně psát výsedek, například `num == 2`:

```python
fun repeat-string-v3(str :: String, num :: Number) -> String:
  if num == 2:
    # Máme zopakovat string dvakrát
    str + str
    # ručně jsme napsali výsledek
  else:
    # Zopakovat string n-krát je to samé jako...

    # ...zopakovat jej (n-mínus-jedna)-krát
    str-n-minus-one = repeat-string-v3(str, n - 1)

    # ...a pak navrch ještě jednou (toto je náš výsledek)
    str-n-minus-one + str
end
```

Ověřte si, že tato funkce funguje, například voláním `repeat-string-v3("a", 4)`. **Zkuste se ale také zamyslet nad tím, pro jaké vstupy funkce fungovat nebude.**

Spoiler: `repeat-string-v3("a", 1)` se nám zacyklí, jako kdybychom žádnou zarážku neměli. Proč? 1 je menší než 2, takže nám pod naší zarážkou "proklouzne":

```python
# Voláme
repeat-string-v2("a", 1)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -1)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -2)
# ...aby to mohla uložit do svojí str-n-minus-one

# A ta v průběhu zavolá
repeat-string-v2("a", -3)
# ...aby to mohla uložit do svojí str-n-minus-one

# ...atd, nikdy se nezastavíme, vždy jen zmenšíme num o jedničku
# na num == 2 nikdy nenarazíme
```

Teď můžeme udělat dvě věci. Buďto se na jedničku vykašlat a říct, že to pro ní prostě fungovat nebude, nebo nějak upravit naší zarážku tak, aby fungovala i pro `num == 1`. Já hlasuji pro druhý způsob.

### Obecný `repeat-string` v4

Naštěstí není třeba dělat žádné velké úpravy, prostě ručně ošetříme i případ `num == 1`:

```python
fun repeat-string-v4(str :: String, num :: Number) -> String:
  if num == 1:
    # Zopakovat string jednou je to samé jako...

    # ...s ním prostě nic neudělat
    str
  else if num == 2:
    # Máme zopakovat string dvakrát
    str + str
  else:
    # Zopakovat string n-krát je to samé jako...

    # ...zopakovat jej (n-mínus-jedna)-krát
    str-n-minus-one = repeat-string-v4(str, n - 1)

    # ...a pak navrch ještě jednou (toto je náš výsledek)
    str-n-minus-one + str
end
```

Pro záporná čísla naše funkce sice pořád nefunguje, ale na ty se už vyklašlat můžeme — pokud se někdo snaží opakovat string "mínus třikrát", je to provokatér a zaslouží si, aby mu spadl prohlížeč. Jsme už prakticky hotovi; ověřte, že `repeat-string-v4` funguje pro všechny rozumné vstupy. Naší `repeat-string-v4` už jen trochu zjednodušíme.

### Obecný `repeat-string` v5

Všimněme si, že případ `num == 2` se vyřeší sám v rámci `else`, protože zopakovat něco dvakrát je to samé jako zopakovat to jednou (a to už umíme) a pak to přidat jednou navrch. Naše finální funkce je tedy

```python
fun repeat-string-v5(str :: String, num :: Number) -> String:
  if num == 1:
    # Zopakovat string jednou je to samé jako...

    # ...s ním prostě nic neudělat
    str
  else:
    # Zopakovat string n-krát je to samé jako...

    # ...zopakovat jej (n-mínus-jedna)-krát
    str-n-minus-one = repeat-string-v5(str, n - 1)

    # ...a pak navrch ještě jednou (toto je náš výsledek)
    str-n-minus-one + str
end
```

První případu (`num == 1`) se říká **base case** a je to tzv. speciální případ — vyčleňujeme za všech možných hodnot num speciálně jedničku a něco pak děláme. Naproti tomu blok kódu za `else` je tzv **obecný případ** (general case) — tento blok provedeme obecně pro všechny ostatní hodnoty `num`.

### Shrnutí

1. Pokusili jsme se ručně ošetřit všechny hodnoty `num` (`v1`). To nefungovalo, protože bychom jich museli ručně popsat nekonečně mnoho.

2. Všimli jsme si, že "zopakovat string n-krát" je to samé jako "zopakovat string n-mínus-jedna-krát a pak ještě jednou". Přepsali jsme naší funkci s použitím tohoto poznatku, ale vznikl nám nekonečný cyklus (`v2`).

3. Přidali jsme zarážku `num == 2`, pro všechna čísla vyšší nebo rovna dvěma tedy naše funkce začala fungovat. K nekonečnýmu cyklu nedošlo proto, že jakmile jsme došli k zarážce, přestali jsme sami sebe volat (tj. přestali jsme se honit za vlastním ocasem).

4. Protože nám u `v3` nefungoval vstup `num == 1`, rozšířili jsme naši zarážku o další speciální případ (`v4`).

5. Konečně, zjednodušili jsme naši funkci tak, že jsme ponechali pouze jeden speciální případ a zbytek výpočtu nechali na tom obecném (`v5`).

Už vám dává smysl, jak `v5` funguje? Super, gratuluji!

### Jak psát podobné funkce

Ve všech podobných funkcích je vždy důležité:

1. Identifikovat obecnou část (to jsme udělali ve `v2`)
2. Najít správnou zarážku, abychom se měli, kdy zastavit (to jsme udělali ve `v3`)

Já osobně to dělám tak, že začnu od zarážky (zpravidla něco "jednoduchého a malého", jako `0` nebo `1`) a pak se zeptám sám sebe:

1. Jaká bude hodnota v zarážce?
2. Co se stane, když bude vstup o jedno větší než zarážka?
3. Jak bych v tomto výpočtu (tj v tom o jedna větším než zarážka) mohl použít výpočet se zarážkou?
4. A jak bych toto mohl zobecnit pro všechny vstupy, které jsou větší než zarážka?

V případě `repeat-string(str, num)` bych začal s prázdnou skořápkou funkce, do které bych postupně doplňoval kód:

```python
fun repeat-string(str :: String, num :: Number) -> String:
  ...
end
```

1. **Jaká bude zarážka a hodnota v ní?** Zkusil bych `num == 1` nebo `num == 0`. Doplním tento **speciální případ** do své funkce a pokračuji:

```python
fun repeat-string(str :: String, num :: Number) -> String:
  if num == 1:
    # Pokud vám není jasné, proč zde je str
    # Mrkněte na předchozí kapitoly
    str
  else:
    ...
end
```

2. **Co se stane, když bude vstup o jedno větší než zarážka?** Opět doplním jako speciální případ.

```python
fun repeat-string(str :: String, num :: Number) -> String:
  if num == 1:
    str
  if num == 2:
    str + str
  else:
    ...
end
```

3. **Jak bych v tomto výpočtu (tj v tom o jedna větším než zarážka) mohl použít výpočet se zarážkou?** Nyní už nepřidávám žádné další případy a jen upravuji hodnotu u `num == 2`:

```python
fun repeat-string(str :: String, num :: Number) -> String:
  if num == 1:
    str
  if num == 2:
    # str jsem nahradil repeat-string(str, 1)
    # protože chci použít hodnotu repeat-string v zarážce
    repeat-string(str, 1) + str
  else:
    ...
end
```

4. **A jak bych toto mohl zobecnit pro všechny vstupy, které jsou větší než zarážka?** Teď se jen snažím zobecnit to, co mám v `num == 2` tak, aby se to dalo použít pro všechny `num > 1`. To, co mám teď je vlastně ""

```python
# num == 2
zopakovat něco dvakrát = zopakovat něco jednou a pak to ještě jednou přidat navrch

# num obecně
zopakovat něco n-krát = ???
```

Po drobné úvaze doplním:

```python
# num == 2
zopakovat něco dvakrát = zopakovat něco jednou a pak to ještě jednou přidat navrch
#                                        ^ (2 - 1)-krát

# num obecně
zopakovat něco n-krát =  zopakovat něco n-mínus-jedna-krát a pak to ještě jednou přidat navrch
```

A mám to! Svůj konkrétní případ pro `num == 2` zobecním následovně:

```python
fun repeat-string(str :: String, num :: Number) -> String:
  if num == 1:
    str
  if num == 2:
    # str jsem nahradil repeat-string(str, 1)
    # protože chci použít hodnotu repeat-string v zarážce
    repeat-string(str, 1) + str
  else:
    # zobecněná verze z num == 2
    repeat-string(str, num - 1) + str
end
```

Nakonec můžu odstranit speciální nezarážkový případ, protože je obsažen v té zobecněné verzi v `else`:

```python
fun repeat-string(str :: String, num :: Number) -> String:
  if num == 1:
    str
  else:
    # funguje i pto num == 2, takže to nemusím řešit ručně
    repeat-string(str, num - 1) + str
end
```

## Řešení miniúkolů z teoretické části

Záladní verze je jednoduchá, prostě

```python
fun repeat-string-four-times(str :: String) -> String:
  str + str + str + str
where:
  repeat-string-four-times("a") is "aaaa"
  repeat-string-four-times("Hello") is "HelloHelloHelloHello"
end
```

Můžeme si ale ušetřit práci a zapsat jí i takto, s použitím `repeat-string-thrice`.

```python
fun repeat-string-thrice(str :: String) -> String:
  # str + str + str jsme nahradili voláním repeat-string-thrice
  # ta totiž to "str + str + str" udělá za nás
  three-times-str = repeat-string-thrice(str)
  three-times-str + str
where:
  repeat-string-four-times("a") is "aaaa"
  repeat-string-four-times("Hello") is "HelloHelloHelloHello"
end
```
